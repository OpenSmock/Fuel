[{"id":0,"href":"/fuel/getting-started/","title":"Getting Started","section":"Fuel","content":"Basic examples We give some class-side messages to facilitate the more common uses of serialization and materialization. The next example writes and reads from file: FLSerializer serialize: \u0026lsquo;stringToSerialize\u0026rsquo; toFileNamed: \u0026lsquo;demo.fuel\u0026rsquo;. materializedString := FLMaterializer materializeFromFileNamed: \u0026lsquo;demo.fuel\u0026rsquo;. We also provide messages for storing into a ByteArray. This can be fine for users of a NoSQL database: anArray := FLSerializer serializeToByteArray: \u0026lsquo;stringToSerialize\u0026rsquo;. materializedString := FLMaterializer materializeFromByteArray: anArray. FileStream In this example we work with files. Note that we set the file in binary mode: FileStream forceNewFileNamed: \u0026lsquo;demo.fuel\u0026rsquo; do: [:aStream | FLSerializer newDefault serialize: \u0026lsquo;stringToSerialize\u0026rsquo; on: aStream binary].\nFileStream oldFileNamed: \u0026lsquo;demo.fuel\u0026rsquo; do: [:aStream | materializedString := (FLMaterializer newDefault materializeFrom: aStream binary) root]. Note also that we are no longer using the class-side messages of previous examples. Now, for both FLSerializer and FLMaterializer, we first create instances with #newDefault to then perform the desired operations. As we will see in next example, creating the instances brings more possibilities. Compressing Of course, you could use stream compressors provided by the system. However, we have detected some errors serializing WideStrings. An example of use: FileStream forceNewFileNamed: \u0026lsquo;number.fuel.zip\u0026rsquo; do: [:aFileStream | |gzip| aFileStream binary. gzip := GZipWriteStream on: aFileStream. FLSerializer newDefault serialize: 123 on: gzip. gzip close. ]. FileStream oldFileNamed: \u0026lsquo;number.fuel.zip\u0026rsquo; do: [:aFileStream | |gzip| aFileStream binary. gzip := GZipReadStream on: aFileStream.\tmaterialization := FLMaterializer newDefault materializeFrom: gzip. gzip close. ]. Showing a progress bar Sometimes it is nice to see progress updates on screen. Use #showProgress in this cases. FileStream forceNewFileNamed: \u0026lsquo;numbers.fuel\u0026rsquo; do: [:aStream | FLSerializer newDefault showProgress; serialize: (1 to: 200000) asArray on: aStream binary ].\nFileStream oldFileNamed: \u0026lsquo;numbers.fuel\u0026rsquo; do: [:aStream | FLMaterializer newDefault showProgress; materializeFrom: aStream binary ]. Package FuelProgressUpdate must be installed. You can use: (ConfigurationOfFuel project version: \u0026lsquo;1.9\u0026rsquo;) load: \u0026lsquo;FuelProgressUpdate\u0026rsquo;. Basic examples We give some class-side messages to facilitate the more common uses of serialization and materialization. The next example writes and reads from file:\nFLSerializer serialize: \u0026lsquo;stringToSerialize\u0026rsquo; toFileNamed: \u0026lsquo;demo.fuel\u0026rsquo;. materializedString := FLMaterializer materializeFromFileNamed: \u0026lsquo;demo.fuel\u0026rsquo;. We also provide messages for storing into a ByteArray. This can be fine for users of a NoSQL database:\nanArray := FLSerializer serializeToByteArray: \u0026lsquo;stringToSerialize\u0026rsquo;. materializedString := FLMaterializer materializeFromByteArray: anArray. FileStream In this example we work with files. Note that we set the file in binary mode:\nFileStream forceNewFileNamed: \u0026lsquo;demo.fuel\u0026rsquo; do: [:aStream | FLSerializer newDefault serialize: \u0026lsquo;stringToSerialize\u0026rsquo; on: aStream binary].\nFileStream oldFileNamed: \u0026lsquo;demo.fuel\u0026rsquo; do: [:aStream | materializedString := (FLMaterializer newDefault materializeFrom: aStream binary) root]. Note also that we are no longer using the class-side messages of previous examples. Now, for both FLSerializer and FLMaterializer, we first create instances with #newDefault to then perform the desired operations. As we will see in next example, creating the instances brings more possibilities.\nCompressing Of course, you could use stream compressors provided by the system. However, we have detected some errors serializing WideStrings. An example of use:\nFileStream forceNewFileNamed: \u0026lsquo;number.fuel.zip\u0026rsquo; do: [:aFileStream | |gzip| aFileStream binary. gzip := GZipWriteStream on: aFileStream. FLSerializer newDefault serialize: 123 on: gzip. gzip close. ]. FileStream oldFileNamed: \u0026lsquo;number.fuel.zip\u0026rsquo; do: [:aFileStream | |gzip| aFileStream binary. gzip := GZipReadStream on: aFileStream.\tmaterialization := FLMaterializer newDefault materializeFrom: gzip. gzip close. ]. Showing a progress bar Sometimes it is nice to see progress updates on screen. Use #showProgress in this cases.\nFileStream forceNewFileNamed: \u0026lsquo;numbers.fuel\u0026rsquo; do: [:aStream | FLSerializer newDefault showProgress; serialize: (1 to: 200000) asArray on: aStream binary ].\nFileStream oldFileNamed: \u0026lsquo;numbers.fuel\u0026rsquo; do: [:aStream | FLMaterializer newDefault showProgress; materializeFrom: aStream binary ]. Package FuelProgressUpdate must be installed. You can use:\n(ConfigurationOfFuel project version: \u0026lsquo;1.9\u0026rsquo;) load: \u0026lsquo;FuelProgressUpdate\u0026rsquo;.\n"},{"id":1,"href":"/fuel/managing-globals/","title":"Managing Globals","section":"Fuel","content":"Let us assume a CompiledMethod is referenced from the graph to serialize. Sometimes we may be interested in storing just the selector and name of the class, because we know it will be present when materializing the graph. However, sometimes we want to really store the method with full detail.This means that given an object graph, there is not an unique way of serializing it. Fuel offers dynamic and static mechanisms to customize this. Default globals By default, Fuel considers following objects as globals, i.e. will store just its name: nil, true, false, and Smalltalk globals. Any Class, Trait, Metaclass or ClassTrait. Any CompiledMethod (except when either it #isInstalled not or #isDoIt, for example, the code is evaluated from Workspace). Some well-known global variables: Smalltalk SourceFiles Transcript Undeclared Display TextConstants ActiveWorld ActiveHand ActiveEvent Sensor Processor ImageImports SystemOrganization World. Custom globals are duplicated In this following code snippet we show that by default the global value is not serialized as a global, and so it is duplicated on materialization. \u0026ldquo;Define a global variable named #SomeGlobal.\u0026rdquo; SomeGlobal := Set new.\n\u0026ldquo;Serialize and materialize the value of #SomeGlobal.\u0026rdquo; FLSerializer serialize: SomeGlobal toFileNamed: \u0026lsquo;g.fuel\u0026rsquo;.\n\u0026ldquo;The materialized object is not the same as the global instance.\u0026rdquo; [ (FLMaterializer materializeFromFileNamed: \u0026lsquo;g.fuel\u0026rsquo;) ~~ SomeGlobal ] assert. But\u0026hellip; How to avoid duplication Instead, in the code below #considerGlobal: is used to specify that it should be stored as global. | aSerializer |\n\u0026ldquo;Define a global variable named #SomeGlobal.\u0026rdquo; SomeGlobal := Set new.\naSerializer := FLSerializer newDefault.\n\u0026ldquo;Tell the serializer to consider #SomeGlobal as global.\u0026rdquo; aSerializer analyzer considerGlobal: #SomeGlobal.\naSerializer serialize: SomeGlobal toFileNamed: \u0026lsquo;g.fuel\u0026rsquo;.\n\u0026ldquo;In this case, the materialized object is the same as the global instance.\u0026rdquo; [ (FLMaterializer materializeFromFileNamed: \u0026lsquo;g.fuel\u0026rsquo;) == SomeGlobal ] assert. This feature is tested in tests-globals protocol of FLBasicSerializationTest as well in FLGlobalEnvironmentTest. Changing the environment It is possible to specify where the global will be looked-up during materialization. The method #globalEnvironment: exists for that purpose, as the following example shows. | aSerializer aMaterializer anEnvironment |\n\u0026ldquo;Define a global variable named #SomeGlobal.\u0026rdquo; SomeGlobal := Set new.\n\u0026ldquo;Tell the serializer to consider #SomeGlobal as global.\u0026rdquo; aSerializer := FLSerializer newDefault. aSerializer analyzer considerGlobal: #SomeGlobal. aSerializer serialize: SomeGlobal toFileNamed: \u0026lsquo;g.fuel\u0026rsquo;.\n\u0026ldquo;Override value for #SomeGlobal.\u0026rdquo; anEnvironment := Dictionary newFrom: Smalltalk globals. anEnvironment at: #SomeGlobal put: {42}.\n\u0026ldquo;In this case, the materialized object is the same as the global instance.\u0026rdquo; FileStream oldFileNamed: \u0026lsquo;g.fuel\u0026rsquo; do: [ :aStream | aStream binary. aMaterializer := FLMaterializer newDefault.\n\u0026quot;Set the environment\u0026quot; aMaterializer globalEnvironment: anEnvironment. [ (aMaterializer materializeFrom: aStream) root = {42} ] assert ]  This feature is tested in the class FLGlobalEnvironmentTest. The global environment can be setted also for serialization (not only materialization), but we don\u0026rsquo;t include an example for that case. Let us assume a CompiledMethod is referenced from the graph to serialize. Sometimes we may be interested in storing just the selector and name of the class, because we know it will be present when materializing the graph. However, sometimes we want to really store the method with full detail.\nThis means that given an object graph, there is not an unique way of serializing it. Fuel offers dynamic and static mechanisms to customize this.\nDefault globals By default, Fuel considers following objects as globals, i.e. will store just its name:\nnil, true, false, and Smalltalk globals. Any Class, Trait, Metaclass or ClassTrait. Any CompiledMethod (except when either it #isInstalled not or #isDoIt, for example, the code is evaluated from Workspace). Some well-known global variables: Smalltalk SourceFiles Transcript Undeclared Display TextConstants ActiveWorld ActiveHand ActiveEvent Sensor Processor ImageImports SystemOrganization World. Custom globals are duplicated In this following code snippet we show that by default the global value is not serialized as a global, and so it is duplicated on materialization.\n\u0026ldquo;Define a global variable named #SomeGlobal.\u0026rdquo; SomeGlobal := Set new.\n\u0026ldquo;Serialize and materialize the value of #SomeGlobal.\u0026rdquo; FLSerializer serialize: SomeGlobal toFileNamed: \u0026lsquo;g.fuel\u0026rsquo;.\n\u0026ldquo;The materialized object is not the same as the global instance.\u0026rdquo; [ (FLMaterializer materializeFromFileNamed: \u0026lsquo;g.fuel\u0026rsquo;) ~~ SomeGlobal ] assert. But\u0026hellip;\nHow to avoid duplication Instead, in the code below #considerGlobal: is used to specify that it should be stored as global.\n| aSerializer |\n\u0026ldquo;Define a global variable named #SomeGlobal.\u0026rdquo; SomeGlobal := Set new.\naSerializer := FLSerializer newDefault.\n\u0026ldquo;Tell the serializer to consider #SomeGlobal as global.\u0026rdquo; aSerializer analyzer considerGlobal: #SomeGlobal.\naSerializer serialize: SomeGlobal toFileNamed: \u0026lsquo;g.fuel\u0026rsquo;.\n\u0026ldquo;In this case, the materialized object is the same as the global instance.\u0026rdquo; [ (FLMaterializer materializeFromFileNamed: \u0026lsquo;g.fuel\u0026rsquo;) == SomeGlobal ] assert. This feature is tested in tests-globals protocol of FLBasicSerializationTest as well in FLGlobalEnvironmentTest.\nChanging the environment It is possible to specify where the global will be looked-up during materialization. The method #globalEnvironment: exists for that purpose, as the following example shows.\n| aSerializer aMaterializer anEnvironment |\n\u0026ldquo;Define a global variable named #SomeGlobal.\u0026rdquo; SomeGlobal := Set new.\n\u0026ldquo;Tell the serializer to consider #SomeGlobal as global.\u0026rdquo; aSerializer := FLSerializer newDefault. aSerializer analyzer considerGlobal: #SomeGlobal. aSerializer serialize: SomeGlobal toFileNamed: \u0026lsquo;g.fuel\u0026rsquo;.\n\u0026ldquo;Override value for #SomeGlobal.\u0026rdquo; anEnvironment := Dictionary newFrom: Smalltalk globals. anEnvironment at: #SomeGlobal put: {42}.\n\u0026ldquo;In this case, the materialized object is the same as the global instance.\u0026rdquo; FileStream oldFileNamed: \u0026lsquo;g.fuel\u0026rsquo; do: [ :aStream | aStream binary. aMaterializer := FLMaterializer newDefault.\n\u0026quot;Set the environment\u0026quot; aMaterializer globalEnvironment: anEnvironment. [ (aMaterializer materializeFrom: aStream) root = {42} ] assert ]  This feature is tested in the class FLGlobalEnvironmentTest. The global environment can be setted also for serialization (not only materialization), but we don\u0026rsquo;t include an example for that case.\n"}]