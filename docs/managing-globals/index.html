<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="Let us assume a CompiledMethod is referenced from the graph to serialize. Sometimes we may be interested in storing just the selector and name of the class, because we know it will be present when materializing the graph. However, sometimes we want to really store the method with full detail.This means that given an object graph, there is not an unique way of serializing it. Fuel offers dynamic and static mechanisms to customize this.">
<meta name="theme-color" content="#FFFFFF"><meta property="og:title" content="" />
<meta property="og:description" content="Let us assume a CompiledMethod is referenced from the graph to serialize. Sometimes we may be interested in storing just the selector and name of the class, because we know it will be present when materializing the graph. However, sometimes we want to really store the method with full detail.This means that given an object graph, there is not an unique way of serializing it. Fuel offers dynamic and static mechanisms to customize this." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://theseion.github.io/fuel/managing-globals/" /><meta property="article:section" content="" />



<title>Managing Globals | Fuel</title>
<link rel="manifest" href="/fuel/manifest.json">
<link rel="icon" href="/fuel/favicon.png" type="image/x-icon">
<link rel="stylesheet" href="/fuel/book.min.4161ce72491bec8afb94acd3b81e1480e4774aca5e9e3e25c4eeeb0a4dff856a.css" integrity="sha256-QWHOckkb7Ir7lKzTuB4UgOR3Sspenj4lxO7rCk3/hWo=" crossorigin="anonymous">
  <script defer src="/fuel/flexsearch.min.js"></script>
  <script defer src="/fuel/en.search.min.33ad50bfb569b140318ea1ee1757fe166f92b94f33eb9833b4832543bf7b7936.js" integrity="sha256-M61Qv7VpsUAxjqHuF1f&#43;Fm&#43;SuU8z65gztIMlQ797eTY=" crossorigin="anonymous"></script>
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->
  
</head>
<body dir="ltr">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    <aside class="book-menu">
      <div class="book-menu-content">
        
  <nav>
<h2 class="book-brand">
  <a href="/fuel/"><img src="/fuel/logo-fuel-header.png" alt="Logo" /><span>Fuel</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>











  









</nav>




  <script>(function(){var a=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(b){localStorage.setItem("menu.scrollTop",a.scrollTop)}),a.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>


 
      </div>
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/fuel/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <strong>Managing Globals</strong>

  <label for="toc-control">
    
    <img src="/fuel/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
  <aside class="hidden clearfix">
    
  
<nav id="TableOfContents"></nav>



  </aside>
  
 
      </header>

      
      
  <article class="markdown"><p>Let us assume a CompiledMethod is referenced from the graph to serialize. Sometimes we may be interested in storing just the selector and name of the class, because we know it will be present when materializing the graph. However, sometimes we want to really store the method with full detail.This means that given an object graph, there is not an unique way of serializing it. Fuel offers dynamic and static mechanisms to customize this.
Default globals
By default, Fuel considers following objects as globals, i.e. will store just its name:
nil, true, false, and Smalltalk globals.
Any Class, Trait, Metaclass or ClassTrait.
Any CompiledMethod (except when either it #isInstalled not or #isDoIt, for example, the code is evaluated from Workspace).
Some well-known global variables: Smalltalk SourceFiles Transcript Undeclared Display TextConstants ActiveWorld ActiveHand ActiveEvent Sensor Processor ImageImports SystemOrganization World.
Custom globals are duplicated
In this following code snippet we show that by default the global value is not serialized as a global, and so it is duplicated on materialization.
&ldquo;Define a global variable named #SomeGlobal.&rdquo;
SomeGlobal := Set new.</p>
<p>&ldquo;Serialize and materialize the value of #SomeGlobal.&rdquo;
FLSerializer
serialize: SomeGlobal
toFileNamed: &lsquo;g.fuel&rsquo;.</p>
<p>&ldquo;The materialized object <em>is not</em> the same as the global instance.&rdquo;
[ (FLMaterializer materializeFromFileNamed: &lsquo;g.fuel&rsquo;) ~~ SomeGlobal ] assert.
But&hellip;
How to avoid duplication
Instead, in the code below #considerGlobal: is used to specify that it should be stored as global.
| aSerializer |</p>
<p>&ldquo;Define a global variable named #SomeGlobal.&rdquo;
SomeGlobal := Set new.</p>
<p>aSerializer := FLSerializer newDefault.</p>
<p>&ldquo;Tell the serializer to consider #SomeGlobal as global.&rdquo;
aSerializer analyzer considerGlobal: #SomeGlobal.</p>
<p>aSerializer
serialize: SomeGlobal
toFileNamed: &lsquo;g.fuel&rsquo;.</p>
<p>&ldquo;In this case, the materialized object <em>is</em> the same as the global instance.&rdquo;
[ (FLMaterializer materializeFromFileNamed: &lsquo;g.fuel&rsquo;) == SomeGlobal ] assert.
This feature is tested in tests-globals protocol of FLBasicSerializationTest as well in FLGlobalEnvironmentTest.
Changing the environment
It is possible to specify where the global will be looked-up during materialization. The method #globalEnvironment: exists for that purpose, as the following example shows.
| aSerializer aMaterializer anEnvironment |</p>
<p>&ldquo;Define a global variable named #SomeGlobal.&rdquo;
SomeGlobal := Set new.</p>
<p>&ldquo;Tell the serializer to consider #SomeGlobal as global.&rdquo;
aSerializer := FLSerializer newDefault.
aSerializer analyzer considerGlobal: #SomeGlobal.
aSerializer
serialize: SomeGlobal
toFileNamed: &lsquo;g.fuel&rsquo;.</p>
<p>&ldquo;Override value for #SomeGlobal.&rdquo;
anEnvironment := Dictionary newFrom: Smalltalk globals.
anEnvironment at: #SomeGlobal put: {42}.</p>
<p>&ldquo;In this case, the materialized object <em>is the same</em> as the global instance.&rdquo;
FileStream oldFileNamed: &lsquo;g.fuel&rsquo; do: [ :aStream |
aStream binary.
aMaterializer := FLMaterializer newDefault.</p>
<pre><code>&quot;Set the environment&quot;
aMaterializer globalEnvironment: anEnvironment.

[ (aMaterializer materializeFrom: aStream) root = {42} ] assert ]
</code></pre>
<p>This feature is tested in the class FLGlobalEnvironmentTest. The global environment can be setted also for serialization (not only materialization), but we don&rsquo;t include an example for that case.
Let us assume a CompiledMethod is referenced from the graph to serialize. Sometimes we may be interested in storing just the selector and name of the class, because we know it will be present when materializing the graph. However, sometimes we want to really store the method with full detail.</p>
<p>This means that given an object graph, there is not an unique way of serializing it. Fuel offers dynamic and static mechanisms to customize this.</p>
<p>Default globals
By default, Fuel considers following objects as globals, i.e. will store just its name:</p>
<p>nil, true, false, and Smalltalk globals.
Any Class, Trait, Metaclass or ClassTrait.
Any CompiledMethod (except when either it #isInstalled not or #isDoIt, for example, the code is evaluated from Workspace).
Some well-known global variables: Smalltalk SourceFiles Transcript Undeclared Display TextConstants ActiveWorld ActiveHand ActiveEvent Sensor Processor ImageImports SystemOrganization World.
Custom globals are duplicated
In this following code snippet we show that by default the global value is not serialized as a global, and so it is duplicated on materialization.</p>
<p>&ldquo;Define a global variable named #SomeGlobal.&rdquo;
SomeGlobal := Set new.</p>
<p>&ldquo;Serialize and materialize the value of #SomeGlobal.&rdquo;
FLSerializer
serialize: SomeGlobal
toFileNamed: &lsquo;g.fuel&rsquo;.</p>
<p>&ldquo;The materialized object <em>is not</em> the same as the global instance.&rdquo;
[ (FLMaterializer materializeFromFileNamed: &lsquo;g.fuel&rsquo;) ~~ SomeGlobal ] assert.
But&hellip;</p>
<p>How to avoid duplication
Instead, in the code below #considerGlobal: is used to specify that it should be stored as global.</p>
<p>| aSerializer |</p>
<p>&ldquo;Define a global variable named #SomeGlobal.&rdquo;
SomeGlobal := Set new.</p>
<p>aSerializer := FLSerializer newDefault.</p>
<p>&ldquo;Tell the serializer to consider #SomeGlobal as global.&rdquo;
aSerializer analyzer considerGlobal: #SomeGlobal.</p>
<p>aSerializer
serialize: SomeGlobal
toFileNamed: &lsquo;g.fuel&rsquo;.</p>
<p>&ldquo;In this case, the materialized object <em>is</em> the same as the global instance.&rdquo;
[ (FLMaterializer materializeFromFileNamed: &lsquo;g.fuel&rsquo;) == SomeGlobal ] assert.
This feature is tested in tests-globals protocol of FLBasicSerializationTest as well in FLGlobalEnvironmentTest.</p>
<p>Changing the environment
It is possible to specify where the global will be looked-up during materialization. The method #globalEnvironment: exists for that purpose, as the following example shows.</p>
<p>| aSerializer aMaterializer anEnvironment |</p>
<p>&ldquo;Define a global variable named #SomeGlobal.&rdquo;
SomeGlobal := Set new.</p>
<p>&ldquo;Tell the serializer to consider #SomeGlobal as global.&rdquo;
aSerializer := FLSerializer newDefault.
aSerializer analyzer considerGlobal: #SomeGlobal.
aSerializer
serialize: SomeGlobal
toFileNamed: &lsquo;g.fuel&rsquo;.</p>
<p>&ldquo;Override value for #SomeGlobal.&rdquo;
anEnvironment := Dictionary newFrom: Smalltalk globals.
anEnvironment at: #SomeGlobal put: {42}.</p>
<p>&ldquo;In this case, the materialized object <em>is the same</em> as the global instance.&rdquo;
FileStream oldFileNamed: &lsquo;g.fuel&rsquo; do: [ :aStream |
aStream binary.
aMaterializer := FLMaterializer newDefault.</p>
<pre><code>&quot;Set the environment&quot;
aMaterializer globalEnvironment: anEnvironment.

[ (aMaterializer materializeFrom: aStream) root = {42} ] assert ]
</code></pre>
<p>This feature is tested in the class FLGlobalEnvironmentTest. The global environment can be setted also for serialization (not only materialization), but we don&rsquo;t include an example for that case.</p>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">





</div>



  <script>(function(){function a(c){const a=window.getSelection(),b=document.createRange();b.selectNodeContents(c),a.removeAllRanges(),a.addRange(b)}document.querySelectorAll("pre code").forEach(b=>{b.addEventListener("click",function(c){a(b.parentElement),navigator.clipboard&&navigator.clipboard.writeText(b.parentElement.textContent)})})})()</script>


 
        
      </footer>

      
  
  <div class="book-comments">

</div>
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      <div class="book-toc-content">
        
  
<nav id="TableOfContents"></nav>


 
      </div>
    </aside>
    
  </main>

  
</body>
</html>












